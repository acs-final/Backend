package acs.aws_final_project.domain.fairyTale.service;

import acs.aws_final_project.domain.body.Body;
import acs.aws_final_project.domain.body.BodyConverter;
import acs.aws_final_project.domain.body.BodyRepository;
import acs.aws_final_project.domain.fairyTale.FairyTale;
import acs.aws_final_project.domain.fairyTale.FairyTaleConverter;
import acs.aws_final_project.domain.fairyTale.FairyTaleRepository;
import acs.aws_final_project.domain.fairyTale.dto.FairyTaleResponseDto;
import acs.aws_final_project.domain.keyword.Keyword;
import acs.aws_final_project.domain.keyword.KeywordConverter;
import acs.aws_final_project.domain.keyword.KeywordRepository;
import acs.aws_final_project.global.response.code.resultCode.ErrorStatus;
import acs.aws_final_project.global.response.exception.handler.SonnetHandler;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.json.simple.parser.ParseException;

import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import software.amazon.awssdk.core.SdkBytes;
import software.amazon.awssdk.core.exception.SdkClientException;
import software.amazon.awssdk.services.bedrockruntime.BedrockRuntimeClient;
import software.amazon.awssdk.services.bedrockruntime.model.*;

import java.nio.charset.StandardCharsets;
import java.security.Key;
import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class SonnetService {

    // sonnet 모델
    @Value("${aws.bedrock.sonnet.model}")
    private String SONNET_MODEL_ID;

    private final BedrockRuntimeClient bedrockRuntimeClient;

    private final ObjectMapper objectMapper = new ObjectMapper();

    private final FairyTaleRepository fairyTaleRepository;
    private final BodyRepository bodyRepository;
    private final KeywordRepository keywordRepository;



    private final String SYSTEM_PROMPT_SONNET = "Create a fairy tale for [gender] kid using these elements: Genre: [Genre] and Challenge: [Challenge]. Write in an enchanting, classic fairy tale style and a satisfying ending. Include vivid descriptions and a moral lesson.\n" +
            "Totally 6 pages of amount.\n" +
//            "Create a prompt text in detail for nova canvas model per 2 pages.\n" +
//            "All images generated by nova canvas model must be consistent style and main character in fairy tale has consistent appearance.\n" +
            "Describe 5 keywords about the story at the end.\n" +
            "Make the result as json format like \n" +
            "\"\n" +
            "{\n" +
            "\"title\":\"...\", \\n\n" +
            "\"body\": \"\\[\n" +
            "{\"page1\": \"...\"},\n" +
            "{\"page2\": \"...\"},\n" +
            "\\]\",\\n\n" +
//            "\"prompt\":\" \"\\[\n" +
//            "{\"prompt1\": \"...\"},\n" +
//            "{\"prompt2\": \"...\"},\n" +
//            "\\]\", \\n\n" +
            "\"keywords\": \"\\[\n" +
            "\"...\"\n" +
            "\\]\"\n" +
            "}\n" +
            "\", which body and keywords are list type and each value of list should be in one line.\n" +
            "All responses in Korean except prompt.";


    @Transactional
    public FairyTaleResponseDto.FairyTaleResultDto createFairyTale(String genre, String gender, String challenge) {
        String message = String.format(
                "genre = %s\n" +
                        "gender = %s\n" +
                        "challenge = $s",
                genre, gender, challenge
        );


        // AI에게 전할 message 생성
        Message requestMessage = Message.builder()
                .content(ContentBlock.fromText(message))
                .role(ConversationRole.USER)
                .build();

        // 프롬프트
        SystemContentBlock systemContentBlock = SystemContentBlock.builder()
                .text(SYSTEM_PROMPT_SONNET)
                .build();

        try {
            // AI 요청을 날린다.
            ConverseResponse response = bedrockRuntimeClient.converse(request -> request
                    .modelId(SONNET_MODEL_ID)
                    .messages(requestMessage)    //질문 text
                    .system(systemContentBlock)  //prompt 설정
                    .inferenceConfig(config -> config
                            .maxTokens(1350)    // 출력 토큰 최대 개수.
                            .temperature(1.0F)  // 랜덤성. 높을 수록 예측 불가. 0 ~ 1 사이 값.
                            .topP(0.9F)));      // 단어 선택 가능성. 1 -> 모든 단어 고려.


            // 응답값을 return
            log.info("Response: {}", response.output().message().content().get(0).text());

            //return response.output().message().content().get(0).text();
            return getSonnetResult(response.output().message().content().get(0).text());
            //return getSonnetResultJO(response.output().message().content().get(0).text());


        } catch (SdkClientException e) {
            log.error(e.toString(), e);
            throw new RuntimeException(e);
        } //catch (ParseException e) {
           // throw new RuntimeException(e);
       // }

    }



    public FairyTaleResponseDto.FairyTaleResultDto getSonnetResult(String sonnetResponse) {

        FairyTaleResponseDto.FairyTaleResultDto myresult = new FairyTaleResponseDto.FairyTaleResultDto();

        try {
            // JSON 파싱을 위한 ObjectMapper 생성
            ObjectMapper objectMapper = new ObjectMapper();
            JsonNode rootNode = objectMapper.readTree(sonnetResponse);



            log.info("RootNode: {}", rootNode);

            // Title 추출
            String title = rootNode.get("title").asText();

            // Body 추출 (page1, page2... 순서대로 정렬)
            JsonNode bodyNode = rootNode.get("body");

            log.info("BodyNode: {}", bodyNode);

            //List<FairyTaleResponseDto.Pages> pages = new ArrayList<>();
            TreeMap<String, String> sortedBody = new TreeMap<>();

            for (JsonNode p: bodyNode){
                p.fields().forEachRemaining(entry -> sortedBody.put(entry.getKey(), entry.getValue().asText()));

            }
            log.info("sortedBody: {}", sortedBody);

            // Body를 하나의 문자열로 합치기
            StringBuilder bodyText = new StringBuilder();
            sortedBody.forEach((key, value) -> bodyText.append(value).append("\n"));

            // Prompt 추출
//            JsonNode promptyNode = rootNode.get("prompt");
//            TreeMap<String, String> sortedPrompt = new TreeMap<>();
//            bodyNode.fields().forEachRemaining(entry -> sortedPrompt.put(entry.getKey(), entry.getValue().asText()));
//
//            log.info("Prompt: {}", sortedPrompt);


            // Keywords 추출
            JsonNode keywordsNode = rootNode.get("keywords");
            List<String> keywords = new ArrayList<>();
            keywordsNode.forEach(keyword -> keywords.add(keyword.asText()));

            // 결과 출력
            System.out.println("Title: " + title);
            System.out.println("\nBody:\n" + bodyText);
            System.out.println("\nKeywords: " + keywords);

            List<Keyword> keywordList;

            FairyTale myFairyTale = FairyTaleConverter.toFairyTale(title);

            fairyTaleRepository.save(myFairyTale);

            sortedBody.forEach((key, value) -> {
                String page = key.substring(4);
                Integer pageNumber = Integer.parseInt(page);
                log.info("page: {}", page);
                log.info("pageNumber: {}", pageNumber);

                Body body = FairyTaleConverter.toBody(value, pageNumber, myFairyTale);
                bodyRepository.save(body);
            });

            keywords.forEach(k -> {
                Keyword keyword = FairyTaleConverter.toKeyword(k, myFairyTale);
                log.info("keyword: {}", k);
                log.info("keyword: {}", keyword);
                keywordRepository.save(keyword);
            });


            return myresult.builder()
                    .fairytaleId(myFairyTale.getFairytaleId())
                    .title(title)
                    .body(sortedBody)
                    .keywords(keywords)
                    .build();

        } catch (Exception e) {
            e.printStackTrace();
            throw new SonnetHandler(ErrorStatus.FAIRYTALE_BADREQUEST);
        }

    }


    public FairyTaleResponseDto.FairyTaleResultDto getFairyTale(Long fairytaleId){

        FairyTale findFairyTale = fairyTaleRepository.findById(fairytaleId).orElseThrow(() -> new SonnetHandler(ErrorStatus.FAIRYTALE_NOT_FOUND));

        List<Body> findBody = bodyRepository.findAllByFairyTale(findFairyTale);

        List<Keyword> findKeyword = keywordRepository.findAllByFairyTale(findFairyTale);

        return FairyTaleResponseDto.FairyTaleResultDto.builder()
                .fairytaleId(fairytaleId)
                .title(findFairyTale.getTitle())
                .body(BodyConverter.toBodies(findBody))
                .keywords(KeywordConverter.toKeywords(findKeyword))
                .build();

    }












/*========================================================================================================================*/




    public Object createFairyTaleByInvoke(String genre, String gender, String challenge) {
        String text = String.format(
                "Create a fairy tale for %s kid using these elements: Genre: %s and Challenge: %s. Write in an enchanting, classic fairy tale style and a satisfying ending. Include vivid descriptions and a moral lesson.\n" +
                        "Totally 7 pages of amount.\n" +
//            "Create a prompt text in detail for nova canvas model per 2 pages.\n" +
//            "All images generated by nova canvas model must be consistent style and main character in fairy tale has consistent appearance.\n" +
                        "Describe 5 keywords about the story at the end.\n" +
                        "Make the result as json format like\n" +
                        "\"\n" +
                        "{\n" +
                        "\"title\":\"...\", \\n\n" +
                        "\"body\": \"\\[\n" +
                        "{\"page1\": \"...\"},\n" +
                        "{\"page2\": \"...\"},\n" +
                        "\\]\",\\n\n" +
//            "\"prompt\":\" \"\\[\n" +
//            "\"prompt1\": \"...\",\n" +
//            "\"prompt2\": \"...\",\n" +
//            "\\]\", \\n\n" +
                        "\"keywords\": \"\\[\n" +
                        "\"...\"\n" +
                        "\\]\"\n" +
                        "}\n" +
                        "\", which body and keywords are list type.\n" +
                        "All responses in Korean except prompt.",
                gender,genre,  challenge
        );

        Map<String, Object> messages = new HashMap<>();
        messages.put("role", "user");

        Map<String, Object> content = new HashMap<>();
        content.put("type","text");
        content.put("text", text);

        messages.put("content", List.of(content));

        log.info("messages: {}", messages);


        Map<String, Object> payload = new HashMap<>();
        payload.put("max_tokens", 1300);
        payload.put("messages", List.of(messages));
        payload.put("anthropic_version", "bedrock-2023-05-31");

        log.info("payload: {}", payload);

//        String requestBody = String.format(
//                "{ \"anthropic_version\": \"bedrock-2023-05-31\", \"max_tokens\": 2048, " +
//                        "\"messages\": [ " +
//                        "  { \"role\": \"user\", \"content\": [{ \"type\": \"text\", \"text\": \"%s. %s\" }," +
//                        "  ] } " +  // ✅ 사용자 입력 설정
//                        //"  { \"role\": \"system\", \"content\": [{ \"type\": \"text\", \"text\": \"%s.\" }] }, " +  // ✅ 시스템 프롬프트 설정
//                        " ]}",
//                text, SYSTEM_PROMPT_SONNET
//        );

        String requestBody = null;
        try {
            requestBody = objectMapper.writeValueAsString(payload);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }

        InvokeModelRequest request = InvokeModelRequest.builder()
                .modelId("anthropic.claude-3-5-sonnet-20240620-v1:0") // ✅ Nova Canvas 모델 사용
                .contentType("application/json")
                .body(SdkBytes.fromUtf8String(requestBody))
                //.body(SdkBytes.fromByteArray(requestBody.getBytes(StandardCharsets.UTF_8)))
                .build();


        InvokeModelResponse response = bedrockRuntimeClient.invokeModel(request);
        String responseBody = new String(response.body().asByteArray(), StandardCharsets.UTF_8);

        log.info("Response: {}", response);

        return responseBody;


    }

    public FairyTaleResponseDto.FairyTaleResultDto getSonnetResultJO(String sonnetResponse) throws ParseException {

        JSONParser jsonParser = new JSONParser();
        JSONObject jsonObject = (JSONObject) jsonParser.parse(sonnetResponse);



        log.info("JsonObject: {}", jsonObject);

        JSONObject title = (JSONObject) jsonObject.get("title");
        log.info("title: {}", title);
        String titleResult = title.toString();

        JSONObject body = (JSONObject) jsonObject.get("body");
        JSONArray bodys = (JSONArray) jsonObject.get("body");
        log.info("body: {}", body);
        log.info("bodys: {}", bodys);
        //ArrayList<String> bodies = body.

        List<FairyTaleResponseDto.Pages> pages = new ArrayList<>();

        for (int i=1; i<8; i++) {
            String key = "page" + i;

            String content = body.get("key").toString();
            FairyTaleResponseDto.Pages page = FairyTaleResponseDto.Pages.builder().page(content).build();
            pages.add(page);
        }


        JSONObject keywords = (JSONObject) jsonObject.get("keywords");
        JSONArray keywordlist = (JSONArray) jsonObject.get("keywords");
        log.info("keywords: {}", keywords);
        log.info("keywordlist: {}", keywordlist);

        for (int i=1; i<6; i++){

        }


        return FairyTaleResponseDto.FairyTaleResultDto.builder()
                .title(titleResult)
                //.body(pages)
                .build();

    }

}
