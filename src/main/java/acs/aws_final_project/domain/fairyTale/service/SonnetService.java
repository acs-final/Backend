package acs.aws_final_project.domain.fairyTale.service;

import acs.aws_final_project.domain.body.Body;
import acs.aws_final_project.domain.body.BodyConverter;
import acs.aws_final_project.domain.body.BodyRepository;
import acs.aws_final_project.domain.fairyTale.Fairytale;
import acs.aws_final_project.domain.fairyTale.FairyTaleConverter;
import acs.aws_final_project.domain.fairyTale.FairyTaleRepository;
import acs.aws_final_project.domain.fairyTale.dto.FairyTaleRequestDto;
import acs.aws_final_project.domain.fairyTale.dto.FairyTaleResponseDto;
import acs.aws_final_project.global.response.code.resultCode.ErrorStatus;
import acs.aws_final_project.global.response.exception.handler.SonnetHandler;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

//import org.json.simple.JSONArray;
//import org.json.simple.JSONObject;
//import org.json.simple.parser.JSONParser;
//import org.json.simple.parser.ParseException;

import org.jsoup.Jsoup;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import software.amazon.awssdk.core.SdkBytes;
import software.amazon.awssdk.core.exception.SdkClientException;
import software.amazon.awssdk.services.bedrockruntime.BedrockRuntimeClient;
import software.amazon.awssdk.services.bedrockruntime.model.*;

import java.nio.charset.StandardCharsets;
import java.util.*;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class SonnetService {

    // sonnet 모델
    @Value("${aws.bedrock.sonnet.model}")
    private String SONNET_MODEL_ID;

    private final BedrockRuntimeClient bedrockRuntimeClient;

    private final ObjectMapper objectMapper = new ObjectMapper();

    private final FairyTaleRepository fairyTaleRepository;
    private final BodyRepository bodyRepository;

    private final FairyTaleService fairyTaleService;



    private final String SYSTEM_PROMPT_SONNET = "Create a fairy tale for [gender] kid using these elements: Genre: [Genre] and Challenge: [Challenge]. Write in an enchanting, classic fairy tale style and a satisfying ending. Include vivid descriptions and a moral lesson.\n" +
            "Totally 4 pages of amount.\n" +
            "Create a prompt text in detail for stable diffusion model per 2 pages.\n" +
            "All images generated by stable diffusion model must be consistent style and main character in fairy tale has consistent appearance.\n" +
            //"Make the result as json format like \n" +
            "The response is always a **valid JSON object** like \n" +
            "\"\n" +
            "{\n" +
            "\"title\":\"...\", \\n" +
            "\"body\": \"\\[\n" +
            "{\"page1\": \"...\"},\n" +
            "{\"page2\": \"...\"},\n" +
            "\\]\",\\n\n" +
            "\"prompt\":\" \"\\[\n" +
            "{\"prompt1\": \"...\"},\n" +
            "{\"prompt2\": \"...\"},\n" +
            "\\]\", \\n\n" +
            "}\n" +
            "\", which body is list type and each value of list should be in one line.\n" +
//            "The body texts have SSML tags for polly service." +
            "All responses are under 2048 tokens." +
            "All responses in Korean except prompt." +
            "Do not use double quotes in any dialogues or direct quotes of pages";
//            "Please make sure that any dialogues or direct quotes in the story are enclosed in **single quotes** (') instead of double quotes (\"), while regular sentences should continue using double quotes.";


    @Transactional
    public FairyTaleResponseDto.FairyTaleResultDto createFairyTale(String genre, String gender, String challenge) {
        String message = String.format(
                "genre = %s\n" +
                        "gender = %s\n" +
                        "challenge = $s",
                genre, gender, challenge
        );


        // AI에게 전할 message 생성
        Message requestMessage = Message.builder()
                .content(ContentBlock.fromText(message))
                .role(ConversationRole.USER)
                .build();

        // 프롬프트
        SystemContentBlock systemContentBlock = SystemContentBlock.builder()
                .text(SYSTEM_PROMPT_SONNET)
                .build();

        try {
            // AI 요청을 날린다.
            ConverseResponse response = bedrockRuntimeClient.converse(request -> request
                    .modelId(SONNET_MODEL_ID)
                    .messages(requestMessage)    //질문 text
                    .system(systemContentBlock)  //prompt 설정
                    .inferenceConfig(config -> config
                            .maxTokens(2048)    // 출력 토큰 최대 개수.
                            .temperature(1.0F)  // 랜덤성. 높을 수록 예측 불가. 0 ~ 1 사이 값.
                            .topP(0.9F)));      // 단어 선택 가능성. 1 -> 모든 단어 고려.


            // 응답값을 return
            log.info("Response: {}", response.output().message().content().get(0).text());

            //return response.output().message().content().get(0).text();
            return getSonnetResult(response.output().message().content().get(0).text());


        } catch (SdkClientException e) {
            log.error(e.toString(), e);
            throw new RuntimeException(e);
        }

    }



    public FairyTaleResponseDto.FairyTaleResultDto getSonnetResult(String sonnetResponse) {

        FairyTaleResponseDto.FairyTaleResultDto myresult = new FairyTaleResponseDto.FairyTaleResultDto();

        try {
            // JSON 파싱을 위한 ObjectMapper 생성
            ObjectMapper objectMapper = new ObjectMapper();

            String fixedJson = preprocessJson(sonnetResponse);

            log.info("fixedJson: {}", fixedJson);

            JsonNode rootNode = objectMapper.readTree(fixedJson);

            log.info("RootNode: {}", rootNode);

            // Title 추출
            String title = rootNode.get("title").asText();

            // Body 추출 (page1, page2... 순서대로 정렬)
            JsonNode bodyNode = rootNode.get("body");

            log.info("BodyNode: {}", bodyNode);

            //List<FairyTaleResponseDto.Pages> pages = new ArrayList<>();
            TreeMap<String, String> sortedBody = new TreeMap<>();

            for (JsonNode p: bodyNode){
                p.fields().forEachRemaining(entry -> {
                    String output = Jsoup.parse(entry.getValue().asText()).text();
                    sortedBody.put(entry.getKey(), output);
                }
                );

            }
            log.info("sortedBody: {}", sortedBody);

            // Body를 하나의 문자열로 합치기
            StringBuilder bodyText = new StringBuilder();
            //sortedBody.forEach((key, value) -> bodyText.append(value).append("\n"));

            StringBuilder resultPage = new StringBuilder();

            List<String> pages = new ArrayList<>(sortedBody.values());
            TreeMap<String, String> resultBody = new TreeMap<>();

            int j = 0;

            for (int i=0; i< pages.size(); i++){

                resultPage.append(pages.get(i));

                if (i%2==1){
                    j++;
                    String key = "page" + j;
                    resultBody.put(key, String.valueOf(resultPage));

                    resultPage = new StringBuilder("");

                }
            }



            // Prompt 추출
            JsonNode promptNode = rootNode.get("prompt");

            log.info("promptNode: {}", promptNode);
            TreeMap<String, String> sortedPrompt = new TreeMap<>();
//		promptNode.fields().forEachRemaining(entry -> sortedPrompt.put(entry.getKey(), entry.getValue().asText()));

            for (JsonNode item : promptNode) {
                item.fields().forEachRemaining(entry -> sortedPrompt.put(entry.getKey(), entry.getValue().asText()));
            }
            log.info("Prompt: {}", sortedPrompt);


            // 결과 출력
            System.out.println("Title: " + title);
            System.out.println("\nBody:\n" + bodyText);

            List<FairyTaleRequestDto.StablediffusionRequestDto> imageRequestDtos = new ArrayList<>();
            List<FairyTaleRequestDto.PollyRequestDto> mp3RequestDtos = new ArrayList<>();

            sortedPrompt.forEach((key,value) -> {
                        int i = 0;
                        String file = title + i;
                        imageRequestDtos.add(FairyTaleConverter.toImageRequestDto(title, file, value));
                    }
            );

            resultBody.forEach((key, value) -> {
                int i = 0;
                String file = title + i;
                mp3RequestDtos.add(FairyTaleConverter.toMp3RequestDto(title,file, value));
            });

            log.info("Async image request: {}", imageRequestDtos);

            Fairytale myFairytale = FairyTaleConverter.toFairyTale(title);

            fairyTaleRepository.save(myFairytale);

            List<FairyTaleResponseDto.StablediffusionResultDto> imageUrls = fairyTaleService.asyncImage(imageRequestDtos, myFairytale);
            List<FairyTaleResponseDto.PollyResultDto> mp3Urls = fairyTaleService.asyncPolly(mp3RequestDtos, myFairytale);


            log.info("image urls: {}", imageUrls);

            sortedBody.forEach((key, value) -> {
                String page = key.substring(4);
                Integer pageNumber = Integer.parseInt(page);
                log.info("page: {}", page);
                log.info("pageNumber: {}", pageNumber);

                Body body = FairyTaleConverter.toBody(value, pageNumber, myFairytale);
                bodyRepository.save(body);
            });

            return myresult.builder()
                    .fairytaleId(myFairytale.getFairytaleId())
                    .title(title)
                    .body(resultBody)
                    .imageUrl(imageUrls)
                    .mp3Url(mp3Urls)
                    //.keywords(keywords)
                    .build();

        } catch (Exception e) {
            e.printStackTrace();
            throw new SonnetHandler(ErrorStatus.FAIRYTALE_BADREQUEST);
        }

    }

    public static String preprocessJson(String rawJson) {
        return rawJson
                .replace("\\\"", "\"")  // 이스케이프 제거
                .replace("\"[", "[")    // 배열을 문자열이 아닌 JSON 배열로 변환
                .replace("]\"", "]")    // 배열 끝 처리
                .replace("\n", " ")   // 줄바꿈 처리
                .replace("\r", "")      // 캐리지 리턴 제거
                .replace("\t", " ");    // 탭을 공백으로 변환
    }















/*========================================================================================================================*/




    public Object createFairyTaleByInvoke(String genre, String gender, String challenge) {
        String text = String.format(
                "Create a fairy tale for %s kid using these elements: Genre: %s and Challenge: %s. Write in an enchanting, classic fairy tale style and a satisfying ending. Include vivid descriptions and a moral lesson.\n" +
                        "Totally 7 pages of amount.\n" +
//            "Create a prompt text in detail for nova canvas model per 2 pages.\n" +
//            "All images generated by nova canvas model must be consistent style and main character in fairy tale has consistent appearance.\n" +
                        "Describe 5 keywords about the story at the end.\n" +
                        "Make the result as json format like\n" +
                        "\"\n" +
                        "{\n" +
                        "\"title\":\"...\", \\n\n" +
                        "\"body\": \"\\[\n" +
                        "{\"page1\": \"...\"},\n" +
                        "{\"page2\": \"...\"},\n" +
                        "\\]\",\\n\n" +
//            "\"prompt\":\" \"\\[\n" +
//            "\"prompt1\": \"...\",\n" +
//            "\"prompt2\": \"...\",\n" +
//            "\\]\", \\n\n" +
                        "\"keywords\": \"\\[\n" +
                        "\"...\"\n" +
                        "\\]\"\n" +
                        "}\n" +
                        "\", which body and keywords are list type.\n" +
                        "All responses in Korean except prompt.",
                gender,genre,  challenge
        );

        Map<String, Object> messages = new HashMap<>();
        messages.put("role", "user");

        Map<String, Object> content = new HashMap<>();
        content.put("type","text");
        content.put("text", text);

        messages.put("content", List.of(content));

        log.info("messages: {}", messages);


        Map<String, Object> payload = new HashMap<>();
        payload.put("max_tokens", 1300);
        payload.put("messages", List.of(messages));
        payload.put("anthropic_version", "bedrock-2023-05-31");

        log.info("payload: {}", payload);

//        String requestBody = String.format(
//                "{ \"anthropic_version\": \"bedrock-2023-05-31\", \"max_tokens\": 2048, " +
//                        "\"messages\": [ " +
//                        "  { \"role\": \"user\", \"content\": [{ \"type\": \"text\", \"text\": \"%s. %s\" }," +
//                        "  ] } " +  // ✅ 사용자 입력 설정
//                        //"  { \"role\": \"system\", \"content\": [{ \"type\": \"text\", \"text\": \"%s.\" }] }, " +  // ✅ 시스템 프롬프트 설정
//                        " ]}",
//                text, SYSTEM_PROMPT_SONNET
//        );

        String requestBody = null;
        try {
            requestBody = objectMapper.writeValueAsString(payload);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }

        InvokeModelRequest request = InvokeModelRequest.builder()
                .modelId("anthropic.claude-3-5-sonnet-20240620-v1:0") // ✅ Nova Canvas 모델 사용
                .contentType("application/json")
                .body(SdkBytes.fromUtf8String(requestBody))
                //.body(SdkBytes.fromByteArray(requestBody.getBytes(StandardCharsets.UTF_8)))
                .build();


        InvokeModelResponse response = bedrockRuntimeClient.invokeModel(request);
        String responseBody = new String(response.body().asByteArray(), StandardCharsets.UTF_8);

        log.info("Response: {}", response);

        return responseBody;


    }

//    public FairyTaleResponseDto.FairyTaleResultDto getSonnetResultJO(String sonnetResponse) throws ParseException {
//
//        JSONParser jsonParser = new JSONParser();
//        JSONObject jsonObject = (JSONObject) jsonParser.parse(sonnetResponse);
//
//
//
//        log.info("JsonObject: {}", jsonObject);
//
//        JSONObject title = (JSONObject) jsonObject.get("title");
//        log.info("title: {}", title);
//        String titleResult = title.toString();
//
//        JSONObject body = (JSONObject) jsonObject.get("body");
//        JSONArray bodys = (JSONArray) jsonObject.get("body");
//        log.info("body: {}", body);
//        log.info("bodys: {}", bodys);
//        //ArrayList<String> bodies = body.
//
//        List<FairyTaleResponseDto.Pages> pages = new ArrayList<>();
//
//        for (int i=1; i<8; i++) {
//            String key = "page" + i;
//
//            String content = body.get("key").toString();
//            FairyTaleResponseDto.Pages page = FairyTaleResponseDto.Pages.builder().page(content).build();
//            pages.add(page);
//        }
//
//
//        JSONObject keywords = (JSONObject) jsonObject.get("keywords");
//        JSONArray keywordlist = (JSONArray) jsonObject.get("keywords");
//        log.info("keywords: {}", keywords);
//        log.info("keywordlist: {}", keywordlist);
//
//        for (int i=1; i<6; i++){
//
//        }
//
//
//        return FairyTaleResponseDto.FairyTaleResultDto.builder()
//                .title(titleResult)
//                //.body(pages)
//                .build();
//
//    }

}
